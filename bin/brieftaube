#!/usr/bin/perl

package Brieftaube;
use strict;
use warnings;
use lib 'lib';
use Curses;
use Mail::IMAPClient;
use Encode qw(encode decode);
use Brieftaube::FolderView;
use Brieftaube::Pager;
use Config::Tiny;
use MIME::QuotedPrint;
use MIME::Base64;

my $config_file = "$ENV{HOME}/.brieftauberc";
my $config;
if ( -e $config_file ) {
    $config = Config::Tiny->read( $config_file, 'utf8' );
    die "Can't read configuration: " . Config::Tiny->errstr . "\n"
      unless $config;
}
my ( $username, $server, $password ) =
  @{ $config->{_} }{qw(username server password)};

if ( not exists $config->{_}->{starttls} and not exists $config->{_}->{ssl} ) {
    $config->{_}->{starttls} = 1;
}

my $curses = Curses->new();
noecho();
curs_set(0);
start_color();

$curses->getmaxyx( my ( $lines, $columns ) );
my $win_index  = newwin( $lines - 1, $columns, 0,          0 );
my $win_mail   = newwin( $lines - 1, $columns, 0,          0 );
my $win_debug  = newwin( $lines - 1, $columns, 0,          0 );
my $win_prompt = newwin( 1,          $columns, $lines - 1, 0 );

$win_index->keypad(1);

$username = prompt( $win_prompt, 'Username' ) unless $username;
$server   = prompt( $win_prompt, 'Server' )   unless $server;
$password = prompt( $win_prompt, 'Password', 1 ) unless $password;

boom("Can't connect unless server is supplied.\n")   unless $server;
boom("Can't connect unless username is supplied.\n") unless $username;
boom("Can't connect unless password is supplied.\n") unless $password;

my $imap = Mail::IMAPClient->new(
    Server   => $server,
    User     => $username,
    Password => $password,
    Uid      => 1,
    $config->{_}->{ssl}      ? ( Ssl      => 1 ) : (),
    $config->{_}->{starttls} ? ( Starttls => 1 ) : (),
);

boom("Can't connect to imap server: $@\n") unless $imap;

my $cache = {};

sub change_folder {
    my ( $imap, $folder ) = @_;
    $imap->select($folder);
    $win_index->getmaxyx( my ( $max_y, $max_x ) );
    my @uids = $imap->sort( 'DATE', 'UTF-8', 'ALL' );
    my $pager = Brieftaube::Pager->new(
        array     => \@uids,
        page_size => $max_y,
    );
    cache_uids( $cache, $imap, @uids );
    my $folder_view = Brieftaube::FolderView->new(
        win   => $win_index,
        imap  => $imap,
        pager => $pager,
        cache => $cache->{ folder_prefix($imap) },
    );
    return $folder_view;
}

sub folder_prefix {
    my $imap = shift;
    my ( $user, $server, $uidvalidity ) =
      ( $imap->User, $imap->Server, $imap->uidvalidity( $imap->Folder ) );
    return "$user\@$server/$uidvalidity/";
}

my $folder_view = change_folder( $imap, 'INBOX' );

$folder_view->display_page;

while (1) {

    my $char = $win_index->getch();

    $folder_view->handle_input($char);

    if ( $char eq 'c' ) {
        my $new_folder = prompt( $win_prompt, "Folder" );
        $folder_view = change_folder( $imap, $new_folder );
        $folder_view->display_page();
    }
    elsif ( $char eq 'q' ) {
        endwin;
        exit 0;
    }
    $win_index->refresh();
}
endwin;
exit 0;

sub get_folder_uids {
    my ( $imap, $cache ) = shift;
    return;
}

sub cache_uids {
    my ( $cache, $imap, @uids ) = @_;
    my $prefix = folder_prefix($imap);

    my %keys = map { $_ => 1 } keys %{ $cache->{$prefix} };
    my @missing_uids;
    for my $uid (@uids) {
        if ( not exists $keys{$uid} ) {
            push @missing_uids, $uid;
        }
    }
    my $body_structures = $imap->fetch_hash( $imap->Range(@missing_uids),
        'ENVELOPE', 'BODYSTRUCTURE' );
    for my $uid ( keys %$body_structures ) {
        $cache->{$prefix}->{$uid} = $body_structures->{$uid};

    }
    return;
}

sub boom {
    endwin();
    die @_;
}

sub dd {
    my ( $ds, $old_win ) = @_;
    use Data::Dumper;
    $win_debug->erase;
    my $dump = Dumper($ds);
    $dump =~ s/\r\n/\n/smxg;
    $win_debug->addstring( 0, 0, $dump );
    $win_debug->getch();
    if ($old_win) {
        $old_win->touchwin;
        $old_win->refresh;
    }
    return;
}

sub prompt {
    my ( $win, $prompt, $noecho ) = @_;
    echo() unless $noecho;
    $win->move( 0, 0 );
    $win->clrtoeol;
    $win->addstring( 0, 0, "$prompt: " );
    my $answer = $win->getstring();
    $win->move( 0, 0 );
    $win->clrtoeol;
    $win->refresh;
    noecho();
    return $answer;
}

sub info {
    $win_prompt->move( 0, 0 );
    $win_prompt->clrtoeol;
    $win_prompt->addstring( '' . $_[0] );
    $win_prompt->refresh();
    return;
}
